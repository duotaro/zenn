---
title: "TypeScriptエンジニアに捧ぐ、Pythonで「any」を撲滅するための型ヒント入門"
emoji: "❓"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ['TypeScript','Python','any','Type Hints',]
published: true
---

# TypeScriptエンジニアに捧ぐ、Pythonで「any」を撲滅するための型ヒント入門

## はじめに：Pythonのコードが怖すぎる

普段TypeScript（以下TS）で、厳格な型定義とコンパイラに守られている私たちが、初めてPythonのコードを見た時に感じる恐怖。それは**「引数も戻り値も、何が入っているのか全くわからない」**という点に尽きます。

```python
# 恐怖のコード
def process_data(data):
    return data["value"] * 2

```

TS脳で見ると、これは `data: any` であり、戻り値も `any` です。「実行してみないと落ちるかどうかわからない」なんて、精神衛生上耐えられません。

しかし、現代のPython（3.9以降）は違います。TSとほぼ同等の「型ヒント（Type Hints）」を書くことができます。GenAI開発などでPythonを触る必要が出てきたTSエンジニアに向けて、**「Pythonで型安全を手に入れるためのマッピング」**を解説します。

## 基本の型定義：TS vs Python

Python 3.9以降、`from typing import List` といったimportは不要になりました。標準の組み込み型を使って、TSのGenericsのように記述できます。

### 変数とプリミティブ

TSの `: type` は、Pythonでも同じく `: type` ですが、型名が異なります。

| 型 | TypeScript | Python |
| --- | --- | --- |
| 整数/浮動小数点 | `number` | `int` / `float` |
| 文字列 | `string` | `str` |
| 真偽値 | `boolean` | `bool` |
| 何でもあり | `any` | `Any` (要import) |

```python
# Python
user_id: int = 101
user_name: str = "Alice"
is_active: bool = True

```

### 配列とオブジェクト（辞書）

ここが一番TSエンジニアにとって馴染みやすい部分です。

:::message
**Note:** Python 3.9未満の古い記事では `List[str]` のように書かれていますが、現在は `list[str]` と小文字で書けます。
:::

**配列 (Array vs list)**

```typescript
// TS
const items: string[] = ["a", "b"];
// または const items: Array<string> = ...

```

```python
# Python
items: list[str] = ["a", "b"]

```

**連想配列 (Record/Map vs dict)**

```typescript
// TS
const scores: Record<string, number> = { math: 90 };

```

```python
# Python
scores: dict[str, int] = {"math": 90}

```

### 関数のシグネチャ

引数の書き方は同じですが、戻り値の型は `->` を使って記述します。

```typescript
// TS
const add = (a: number, b: number): number => {
    return a + b;
};

```

```python
# Python
def add(a: int, b: int) -> int:
    return a + b

```

### Union型とOptional

「`null`（Pythonでは `None`）かもしれない」という表現は、Python 3.10以降 `|` を使って書けます。

```typescript
// TS
const findUser = (id: number): string | null => { ... }

```

```python
# Python
def find_user(id: int) -> str | None:
    ...

```

## 応用：TypedDictでオブジェクトの形を定義する

TSエンジニアが一番欲するのが **`interface` や `type` によるオブジェクトの型定義**でしょう。
Pythonの `dict` はそのままだと `dict[str, Any]` になりがちですが、`TypedDict` を使うことで構造を定義できます。

APIレスポンスの型定義などに必須です。

**TypeScript (Interface)**

```typescript
interface UserConfig {
    id: number;
    role: "admin" | "user"; # String Literal Types
    theme?: string;         # Optional
}

```

**Python (TypedDict)**

```python
from typing import TypedDict, Literal

class UserConfig(TypedDict):
    id: int
    role: Literal["admin", "user"] # Pythonでもリテラル型が使える！
    theme: str # ※PythonのTypedDictでのOptional扱いは少し特殊（total=Falseなどを使う）

# 使用例
config: UserConfig = {
    "id": 1,
    "role": "admin",
    "theme": "dark"
}

```

これで `config["id"]` と打った瞬間に、エディタが型を認識してくれるようになります。

## メリット：VS Codeが味方になる

ここまで型を書くと、Python開発環境（VS Code + Pylance拡張機能）は劇的に進化します。

1. **オートコンプリートが効く:**
`list[str]` と定義しておけば、ループの中で `.upper()` などのメソッドがサジェストされます。
2. **静的解析で怒られる:**
`str` を期待している関数に `int` を渡すと、実行前に赤線が出ます。

TSで当たり前に享受していた「守られている安心感」が、Pythonでも手に入ります。

## まとめと実践への誘導

Pythonは「動的型付け言語」ですが、現代のPythonは**「型ヒントを書いて静的解析ツールでチェックする言語」**へと進化しています。
TSエンジニアの皆さん、恐れることはありません。構文の差さえ埋めれば、Pythonは強力な武器になります。

---

**さて、文法は理解できました。次は何を作りますか？**

型ヒントの基礎を抑えたら、次は実践です。
実際にこの型ヒントをフル活用して、**OpenAI APIを使ったチャットボットをゼロから構築するハンズオン（環境構築〜実装）** を、以下のブログで公開しています。

TSエンジニア視点で「ここはハマりやすい」というポイントも交えて書いたので、ぜひ挑戦してみてください。

[Pythonで「記憶を持った」CLIチャットボットを作るまでの1週間【GenAIOpsロードマップ Week 1】](https://it-innovation.hatenablog.com/entry/2025/12/27/225523)
